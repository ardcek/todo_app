import 'package:drift/drift.dart';
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:todo_app/features/tasks/data/notification_service.dart';
import 'package:todo_app/features/tasks/models/task.dart';
import 'package:todo_app/core/database/database.dart';

part 'task_repository.g.dart';

@riverpod
TaskRepository taskRepository(TaskRepositoryRef ref) {
  return TaskRepository(ref.watch(appDatabaseProvider.future), ref);
}

@riverpod
Future<AppDatabase> appDatabase(AppDatabaseRef ref) async {
  return await AppDatabase.getInstance();
}

class TaskRepository {
  TaskRepository(this._db, this.ref) {
    debugPrint('Created TaskRepository with database: $_db');
  }

  final Future<AppDatabase> _db;
  final TaskRepositoryRef ref;

  Future<List<Task>> getAllTasks() async {
    try {
      final db = await _db;
      final tasks = await (db.select(db.tasks)
        ..orderBy([
          (t) => OrderingTerm(expression: t.orderIndex),
        ]))
        .get();
      
      debugPrint('Retrieved ${tasks.length} tasks from database');
      return tasks.map((dbTask) {
        debugPrint('Converting task ${dbTask.id} to model');
        return Task(
          id: dbTask.id,
          title: dbTask.title,
          note: dbTask.note,
          dueDate: dbTask.dueDate,
          reminderDate: dbTask.reminderDate,
          priority: dbTask.priority,
          project: dbTask.project,
          completed: dbTask.completed,
          orderIndex: dbTask.orderIndex,
          createdAt: dbTask.createdAt,
          updatedAt: dbTask.updatedAt,
          deletedAt: dbTask.deletedAt,
        );
      }).toList();
    } catch (e, stack) {
      debugPrint('Error getting tasks: $e');
      debugPrint('Stack trace: $stack');
      return [];
    }
  }

  Future<Task> createTask(String title) async {
    try {
      final db = await _db;
      final now = DateTime.now();
      final maxOrderIndexQuery = await (db.select(db.tasks)
            ..orderBy([(t) => OrderingTerm.desc(t.orderIndex)])
            ..limit(1))
          .map((t) => t.orderIndex)
          .getSingleOrNull();

      final maxOrderIndex = maxOrderIndexQuery ?? 0;

      final taskId = await db.into(db.tasks).insert(
            TasksCompanion.insert(
              title: title,
              orderIndex: maxOrderIndex + 1,
              createdAt: now,
              updatedAt: now,
            ),
          );

      final task = await (db.select(db.tasks)..where((t) => t.id.equals(taskId)))
          .getSingle();
          
      final newTask = Task(
        id: task.id,
        title: task.title,
        note: task.note,
        dueDate: task.dueDate,
        reminderDate: task.reminderDate,
        priority: task.priority,
        project: task.project,
        completed: task.completed,
        orderIndex: task.orderIndex,
        createdAt: task.createdAt,
        updatedAt: task.updatedAt,
        deletedAt: task.deletedAt,
      );

      if (task.dueDate != null) {
        try {
          await ref.read(notificationServiceProvider).scheduleDueNotification(newTask);
        } catch (e) {
          debugPrint('Error scheduling notification: $e');
        }
      }

      return newTask;
    } catch (e, stack) {
      debugPrint('Error creating task: $e');
      debugPrint('Stack trace: $stack');
      rethrow;
    }
  }

  Future<void> updateTask(Task task) async {
    try {
      final db = await _db;
      await (db.update(db.tasks)..where((t) => t.id.equals(task.id))).write(
            TasksCompanion(
              title: Value(task.title),
              note: Value(task.note),
              dueDate: Value(task.dueDate),
              reminderDate: Value(task.reminderDate),
              priority: Value(task.priority),
              project: Value(task.project),
              completed: Value(task.completed),
              orderIndex: Value(task.orderIndex),
              createdAt: Value(task.createdAt),
              updatedAt: Value(DateTime.now()),
              deletedAt: Value(task.deletedAt),
            ),
          );

      try {
        if (task.dueDate != null) {
          await ref.read(notificationServiceProvider).scheduleDueNotification(task);
        } else {
          await ref.read(notificationServiceProvider).cancelNotification(task);
        }
      } catch (e) {
        debugPrint('Error updating notification: $e');
      }
    } catch (e, stack) {
      debugPrint('Error updating task: $e');
      debugPrint('Stack trace: $stack');
      rethrow;
    }
  }

  Future<void> deleteTask(int id) async {
    try {
      final db = await _db;
      final task = await (db.select(db.tasks)..where((t) => t.id.equals(id))).getSingle();
      await (db.delete(db.tasks)..where((t) => t.id.equals(id))).go();
      
      try {
        await ref.read(notificationServiceProvider).cancelNotification(Task(
          id: task.id,
          title: task.title,
          note: task.note,
          dueDate: task.dueDate,
          reminderDate: task.reminderDate,
          priority: task.priority,
          project: task.project,
          completed: task.completed,
          orderIndex: task.orderIndex,
          createdAt: task.createdAt,
          updatedAt: task.updatedAt,
          deletedAt: task.deletedAt,
        ));
      } catch (e) {
        debugPrint('Error canceling notification: $e');
      }
    } catch (e, stack) {
      debugPrint('Error deleting task: $e');
      debugPrint('Stack trace: $stack');
      rethrow;
    }
  }
}